---
title: Captive portal for embedded systems 
date: 2018-08-16 22:36:19.000000000 +05:30
published: false
classes: wide
categories:
- Articles
- Tutorial
tags:
- IoT
- Embedded systems
- Wireless
- Wi-Fi

excerpt: "Captive portals are quiet popular in Wi-Fi deployments. They are quiet useful to improve user experience in an IoT device. This article looks at implementing a simplified captive portal for an embedded system."

---
<style>
div {
  text-align: justify;
  text-justify: inter-word;
}
</style>


{% include base_path %}

## Introduction

Captive portals are those sign in pages that pops up when you connect to a hotel or airport Wi-Fi. They present a web form to enter sign-on details that will be used to authenticate user access. 

This same concept is useful in the case of a Wi-Fi enabled IoT device. Most of these devices comes up as an access point (AP) off the shelf. A user or an app then connects to this access point to transfer provisioning information to the device over a TCP connection. This can either be a direct socket connection or a HTTP request. In case of a user directly connecting to the AP and entering data into a web page without a dedicated mobile app, the user needs to enter an IP address of device name into the browser to navigate to the configuration page. This is where captive portals comes in handy. 

Captive portal is a mechanism by which a system or a browser detects the availability of WAN connectivity. The concept is quiet simple. The operating system or browser will try to access a fixed URL. If the response is a `200 OK` and a know content it implies that the system has WAN connectivity. If the request time out, then there is no WAN connection. When the network infrastructure wants a user to provide information to start using the network then the DNS will reply with the IP address of a "log-in" page rather than that of the original captive portal. When this "unknown" content is seen by the OS or the browser, it will pop up the "sign-on required" banner.

On an embedded system, a full DNS is not efficient. However, for a captive portal implementation, we need a simple blind redirect DNS which always send the same response to any address resolution queries that come in.

## DNS format

To understand how a blind DNS forward works, we need to first understand the basics of a DNS request response format. While we will not go through the entirety of RFC-1035, we will go through the essential sections. 

Typically DNS works on UDP port 53. An over simplified view of a DNS server is that it is a huge lookup table to map host names to IP addresses. Practically, they are partitioned into zones and arranged in a tree for incremental resolution.  

Section `4.1` of the RFC talks about request and response format of a DNS query. The image below shows a generic query format.  

{% include image.html
	img="/images/posts/captivePortal/DNS_genericStructure.png"
	width="480"
	caption="Generic format DNS "
%}

The header section is always present. It contains fields that determines the type of query and which of the following sections are present. It contains the following fields. 

{% include image.html
	img="/images/posts/captivePortal/queryFlags.png"
	width="480"
	caption="Generic format DNS "
%}

- `ID` is a 16 bit number generated by the originator of the query. Response will contain the same ID for matching it with the request. 
- `QR` will be 0 for query and 1 for response. 
- `OPCODE` mentions the kind of query. We are interested only in standard queries. This is denoted by a 0.
- `AA` will be present in only in responses and indicates whether the responding nameserver is an authority for the domain name. 
- `TC` denotes whether the message is truncated due to length. 
- `RD` an optional recursive query desired bit that is copied into the response.  
- `RA` bit notifying whether or not recursion is available in the nameserver. 
- `Z` Reserved for future use. Must be Zeroed out. 
- `RCODE` 4 bit field set in the response to indicate error conditions. 
  - 0 for no error
  - 1 for query format errors
  - 2 for server failure
  - 3 for name error . Meaningful only for responses from an authoritative name server. 
  - 4 Not implemented. i.e the server does not support this kind of queries. 
  - 5 refused. 

-  


A wireshark capture of the header looks like this:

{% include image.html
	img="/images/posts/captivePortal/queryFlags_wireshark.png"
	width="480"
	caption="Generic format DNS "
%}







