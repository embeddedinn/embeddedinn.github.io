---
title: A Practical Guide to RISC-V Interrupts-Navigating the Acronym Landscape
date: 2024-08-21 21:49:06.000000000 -07:00
classes: wide
published: false
categories:
- Articles
- Tutorial
tags:
- RISCV
- Interrupts
- QEMU
- 


header:
  teaser: "images/posts/SWIG-C-DS/SWIG-C-DS-Banner.png"
  og_image: "images/posts/SWIG-C-DS/SWIG-C-DS-Banner.png"
excerpt: "Interrupt handling in RISC-V has evolved over time. This post aims to provide a practical guide to hte various RISC-V interrupt architectures and how to navigate the acronym landscape. We will explore the various interrupt architectures and controllers ranging from the simple CLINT and PLIC to the more complex ones like APLIC and IMSIC. We will also explore how to handle interrupts in RISC-V using QEMU and the RISC-V toolchain."
---

<style>
div {
  text-align: justify;
  text-justify: inter-word;
}
</style>

{% include base_path %}

Interrupt handling in RISC-V has evolved over time. This post aims to provide a practical guide to the various RISC-V interrupt architectures and how to navigate the acronym landscape. We will explore the various interrupt architectures and controllers ranging from the simple CLINT and PLIC to the more complex ones like APLIC and IMSIC. We will also explore how to handle interrupts in RISC-V using QEMU and the RISC-V toolchain.

## Ground Zero for the absolute beginner 

Though this article is not indented for the absolute beginner, it is important to understand the basics of interrupts before diving into the more complex interrupt controllers.

### Interrupts, interrupt controller, traps and CPU exceptions

Interrupts are a mechanism by which a CPU can be interrupted from its current task to handle a higher priority task. Interrupts can be generated by external devices, software, or timers. The interrupt controller is a hardware component that manages the interrupts and decides which interrupt to service first based on priority. CPU exceptions are similar to interrupts but are generated internally by the CPU in response to certain conditions like divide by zero, page faults, etc. A trap is a synchronous exception that is generated by the CPU in response to a specific instruction like a system call. Traps are often used to switch between machine modes in RISC-V.

A CPU design could include an internal low latency interrupt controller like the `Core Local Interruptor (CLINT)` in RISC-V. The CLINT is responsible for handling software and timer interrupts which are the basic, and essential interrupts in any system. The external interrupt controller allows the design to handle more complex systems with a large number of interrupt sources. The `Platform-Level Interrupt Controller (PLIC)` is an example of an external interrupt controller in RISC-V. External interrupt controllers are designed to handle a large number of interrupt sources arising from complex peripherals hooked up to the CPU and can even handle multi-core interrupt routing.

The RISC-V architecture defines interrupt specific registers and interrupt handling mechanisms that allow the CPU to handle interrupts efficiently. Some of these are also isolated and replicated across privilage levels in the RISC-V architecture. i.e there are separate interrupt registers for the machine, supervisor, and user modes for some interrupts like the timer and SW interrupts. Understanding these mechanisms is essential for developers working on RISC-V systems. We will look into the details of these interrupt controllers in the following sections.

### Vectoring and Delegation

A vectored interrupt is an interrupt that tells the CPU which interrupt handler to execute based on the interrupt source. In RISC-V devices using the `CLINT`, the `mtvec` register is used to store the base address of the interrupt handler. The CPU uses this address to jump to the interrupt handler when an interrupt occurs. Delegation is the process by which interrupts are delegated to different privilege levels in the RISC-V architecture. The `mideleg` and `medeleg` registers are used to delegate interrupts to the supervisor and machine modes respectively. This allows the CPU to handle interrupts at different privilege levels efficiently.

Some relatively simpler CPU architectures like the ARM Cortex-M series have a fixed vector table that is used to handle interrupts. In these architectures, the interrupt handler is determined by the interrupt number and the CPU jumps to the corresponding address in the vector table. This is a simpler mechanism compared to the vectored interrupt mechanism used in RISC-V


## Environment setup

We will be using the upstream gcc ELF toolchain for RISC-V and QEMU for running the RISC-V binaries. The following steps will guide you through setting up the environment for running RISC-V binaries on QEMU.

I am using a clean Ubuntu 22.04 WSL2 environment for this setup. The steps should be similar for other Linux distributions.

 ### QEMU setup

    ```bash
    sudo apt install qemu-system-misc
    ```

    We will be using the 32-bit `virt` model for our RISC-V binaries. In the next step, we will setup a linker script for the RISC-V binaries to match the memory layout of the `virt` model.

    The `virt` model is a simple RISC-V machine model that provides a basic memory layout and peripheral devices. It implements a CLINT and PLIC for handling interrupts. We will update the environment to use different models as we explore the different interrupt controllers.

  ### Toolchain, debugger and picolib setup
    
    We will use the upstream RISC-V GCC toolchain for building RISC-V binaries and `gdb-multiarch` for debugging.
    
    `Picolibc` is a minimal C library for embedded systems that can be sued with the RISC-V toolchain. `Picolibc` provides a GCC `.specs` file which sets the search path for header files and picolibc libraries.

    To install the RISC-V toolchain, debugger and picolibc, run the following commands:

    ```bash
    sudo apt update
    sudo apt install build-essential gdb-multiarch gcc-riscv64-unknown-elf picolibc-riscv64-unknown-elf
    ```

    Lets write a simple hello world program to test the build setup:

    ```c
    #include <stdio.h>

    int main() {
        printf("Hello, RISC-V!\n");
        return 0;
    }
    ```

    We also need to setup a linker script for the RISC-V binaries. The linker script defines the memory layout of the binary and is used by the linker to generate the final binary. The following linker script can be used for the `virt` model:

    ```ld
    __flash = 0x80000000;
    __flash_size = 0x00080000;
    __ram = 0x80080000;
    __ram_size = 0x40000;
    __stack_size = 1k;

    INCLUDE picolibc.ld
    ```

    For the `virt` model, execution starts at `0x80000000` so the first instruction in the application needs to land there. `Picolibc` on RISC-V puts _start at the first location in read-only memory

    To generate a binary using the RISC-V toolchain and `Picolibc` , you can use the following command:

    ```bash
    riscv64-unknown-elf-gcc -o hello.elf hello.c \
                    --specs=picolibc.specs --oslib=semihost \
                    -march=rv32imac -mabi=ilp32 \
                    -Tvirt.ld 
    ```

    We use the oslib flag to specify the semihosting library for I/O operations. This allows us to run the binary on QEMU and see the output even without a full I/O driver setup.

    Running the `file` command on the generated binary should show that it is a RISC-V ELF binary:

    ```bash
    hello.elf: ELF 32-bit LSB executable, UCB RISC-V, RVC, soft-float ABI, version 1 (SYSV), statically linked, with debug_info, not stripped
    ```

  ### Running RISC-V bare-metal binaries on QEMU

    To execute the RISC-V binary on QEMU, you can use the following command:

    ```bash
    qemu-system-riscv32 -semihosting-config enable=on -monitor none \
                        -serial none -nographic \
                        -machine virt,accel=tcg -cpu rv32 -bios none \
                        -kernel hello.elf
    ```

We have now setup the environment to build and run RISC-V binaries on QEMU. In the next sections, we will explore the various RISC-V interrupt controllers and how to handle interrupts in RISC-V systems and use this setup to demonstrate the interrupt handling mechanisms.


## Overview of RISC-V Interrupt 

The RISC-V architecture defines a set of Control and Status Registers (CSRs) that are used to manage interrupts. These CSRs are used to enable, disable, and acknowledge interrupts, as well as to set their priority levels. The CSRs defined to configure and handle interrupts depends on the overall system interrupt architecture. A simple CLINT based system may have fewer interrupt related CSRs compared to a complex system with AIA.

Irrespective of the complexity of the system, understanding interrupts is essential for developers working on RISC-V systems. This knowledge is crucial for designing efficient interrupt handling mechanisms, debugging interrupt-related issues, and optimizing system performance. By understanding the various interrupt controllers and their features, developers can make informed decisions about which controller to use based on their system requirements.

When trying to approach RISC-V interrupt handling, one is often bombarded with a plethora of acronyms like CLINT, CLIC, PLIC, APLIC, IMSIC, etc. These acronyms can be overwhelming for beginners and even experienced developers. This is the primary reason for this post that intends to demystify these acronyms and provide a practical guide to RISC-V interrupt handling.

### Interrupt Types and Sources
  Before diving into the various interrupt controllers, it is essential to understand the different types of interrupts and their sources. Interrupts can be broadly classified into three categories: external, software, and timer interrupts. External interrupts are generated by external devices connected to the CPU, such as peripherals or other processors. Software interrupts are generated by software running on the CPU and are used for inter-processor communication or signaling. Timer interrupts are generated by the system timer and are used for scheduling tasks or time-sensitive operations.
  
### Privilege Levels and Interrupt Handling
    The RISC-V architecture defines four main privilege levels: Machine, Supervisor, User, and Hypervisor. Each privilege level has its own set of interrupt handling mechanisms and registers. The Machine privilege level has the highest priority and can handle all interrupts, while the Supervisor and User levels have limited access to certain interrupts. The Hypervisor privilege level is used for virtualization and has its own interrupt handling mechanisms.

## Core Local Interruptor (CLINT)
CLINT is a simple, non-vectored interrupt controller focused on simplicity. It is designed to handle software and timer interrupts in a single-core system. The CLINT is responsible for generating interrupts based on timer events and software requests. It provides a basic interrupt handling mechanism that is suitable for simple systems with a single processor core.

The main CSRs used by the CLINT are discussed below. Note that there registers may have counterparts in the supervisor and user modes for some interrupts. We are focusing on the machine mode registers here.

- `mstatus` - Status register that controls the interrupt enable and privilege mode.
- `mtime` - Machine timer register that stores the current time.
- `mtimecmp` used to set the timer interrupt threshold. When the `mtime` value exceeds the `mtimecmp` value, a timer interrupt is generated.
- `mip` - Machine interrupt pending register that stores the pending interrupt bits.
- `mie` - Machine interrupt enable register that enables specific interrupts.
- `mtvec` - Machine trap vector base address register that stores the base address of the interrupt handler.
- `mideleg` - Machine interrupt delegation register that delegates interrupts to the supervisor mode. (we will look into this in detail later.)
- `mtvt` - Machine timer vector table register that stores the base address of the timer interrupt handler.


### CLINT hands-on example

Let's look at a simple example of setting up the CLINT for a RISC-V system. We will configure the CLINT to generate a timer interrupt after a specific time interval. The interrupt handler will print a message to the console when the interrupt occurs. We will use the setup we created earlier to run the example on QEMU.

Note the GCC pragma `interrupt` is used to define the interrupt handler. This pragma tells the compiler that the function is an interrupt handler and should be placed at the interrupt vector address.

```c
#include <stdio.h>
#include <stdint.h>

#define CLINT_BASE 0x2000000
#define MTIMECMP 0x4000
#define MTIME 0xBFF8


void __attribute__((interrupt)) timer_interrupt_handler() {
    printf("Timer interrupt occurred!\n");
}

void setup_clint() {
    // Set the timer interrupt threshold
    volatile uint64_t *mtimecmp = (uint64_t *)(CLINT_BASE + MTIMECMP);
    *mtimecmp = 1000000; // Set the threshold to 1 million cycles

    // Enable the timer interrupt
    volatile uint32_t *mie = (uint32_t *)(CLINT_BASE + 0x300);
    *mie = 0x80; // Enable the timer interrupt

    // Set the timer interrupt handler
    volatile uint64_t *mtvec = (uint64_t *)(CLINT_BASE + 0x3000);
    *mtvec = (uint64_t)timer_interrupt_handler;
}

int main() {
    setup_clint();

    // Wait for the interrupt to occur
    while (1);

    return 0;
}
```





## 3. Core-Local Interrupt Controller (CLIC)
- Introduction to CLIC
  - Overview of the Core-Local Interrupt Controller.
- Features and Advantages
  - How CLIC differs from CLINT in terms of priority and pre-emption.
- Hands-On Example: Setting Up CLIC
  - Step-by-step guide to configuring CLIC for a simple interrupt handling scenario.

## 4. Advanced Platform-Level Interrupt Controller (APLIC)
- What is APLIC?
  - Introduction to the Advanced Platform-Level Interrupt Controller.
- Differences from PLIC
  - How APLIC is designed for systems with a high number of interrupt sources.
- APLIC Configuration Example
  - Practical example of setting up APLIC in a RISC-V environment.

## 5. Platform-Level Interrupt Controller (PLIC)
- Overview of PLIC
  - Explanation of PLIC’s role in handling external interrupts in a RISC-V system.
- Interrupt Prioritization and Contexts
  - How PLIC manages multiple interrupt sources with priority levels.
- Example: PLIC in Action
  - Hands-on example demonstrating PLIC configuration for a specific use case.

## 6. Interrupt Message Signaled Interrupt Controller (IMSIC)
- Introduction to IMSIC
  - Explanation of IMSIC’s role in managing interrupts using message signaling.
- How IMSIC Works
  - How IMSIC differs from traditional interrupt controllers.
- Hands-On Guide: Using IMSIC
  - Example of setting up and using IMSIC in a RISC-V system.

## 7. Comparing the Interrupt Controllers
- CLINT vs. CLIC vs. APLIC vs. PLIC vs. IMSIC
  - Side-by-side comparison of the different interrupt controllers.
  - Use cases for each controller based on system requirements.

## 8. Hands-On Implementation with QEMU
- Setting Up a Simple Interrupt-Driven Application
  - Practical example of creating an interrupt-driven application using one of the controllers.
- Debugging Interrupts
  - Tips and tools for debugging interrupt handling in RISC-V systems.

## 9. Conclusion
- Recap of Key Points
  - Summary of the main concepts covered in the article.
- Future Trends in RISC-V Interrupt Handling
  - Brief discussion on emerging trends and future developments in RISC-V interrupts.

## 10. Additional Resources
- Documentation and Specifications
  - Links to official RISC-V interrupt controller specifications.
- Further Reading
  - Suggested articles, books, and papers for deeper understanding.
